#!/usr/bin/env node

import fs from "fs";
import child_process from "child_process";
import { AssemblyState } from "@defasm/core";

import { ELFHeader, ProgramHeader, SectionHeader } from "./elf.js";


let args = process.argv.slice(2);
let code = undefined;
let sizeOutFD = null;
let execute = false;
let outputFile = null, inputFile = null;
let runtimeArgs = [];
let assemblyConfig = {};

const ELF_SIZE = ELFHeader.length + ProgramHeader.length;

if(args[0] === '-h' || args[0] === '--help')
{
    console.log(
`Usage: defasm [file] [--init-addr=num] [--intel] [--output outfile] [--size-out=fd] [--run [arguments...]]
    --init-addr     Set the starting address of the program
    --intel         Use Intel syntax when assembling (defaults to AT&T)
    --output        The path to the output file (defaults to 'a' in current
                    directory, or /tmp/asm if --run is provided).
    --size-out      A file descriptor to write the number (in ASCII) of bytes
                    generated by the assembler to.
    --run           If given, the program will assemble the code, then
                    immediately execute it. All parameters following this flag
                    are sent to the program as runtime arguments.`
    );
    process.exit();
}

try
{
    while(args.length > 0)
    {
        let arg = args.shift();
        if(arg[0] !== '-')
        {
            inputFile = arg;
            continue;
        }

        if(arg.startsWith('--init-addr='))
        {
            assemblyConfig.baseAddr = parseInt(arg.slice('--init-addr='.length));
            if(isNaN(assemblyConfig.baseAddr))
                throw "--init-addr expects a number";
            const minAddr = parseInt(fs.readFileSync("/proc/sys/vm/mmap_min_addr")) + ELF_SIZE;
            if(assemblyConfig.baseAddr < minAddr)
                throw `--init-addr must be >= ${minAddr.toString(16)}`;
        }
        else if(arg.startsWith('--size-out='))
        {
            sizeOutFD = parseInt(arg.slice('--size-out='.length));
            if(isNaN(sizeOutFD))
                throw "--size-out expects a file descriptor";
        }
        else switch(arg)
        {
            case '-r':
            case '--run':
                execute = true;
                runtimeArgs = args;
                args = [];
                break;

            case '-o':
            case '--output':
                
                outputFile = args.shift();
                if(outputFile === undefined)
                    throw "No output file given";
                break;

            case '-i':
            case '--intel':
                assemblyConfig.intel = true;
                break;
            
            default:
                throw "Unknown flag " + arg;
        }
    }

    if(outputFile === null)
        outputFile = execute ? '/tmp/asm' : 'a';

    if(inputFile === null)
    {
        code = "";
        process.stdin.on("data", x => code += x.toString());
        process.stdin.on("end", assemble);
    }
    else
    {
        try { code = fs.readFileSync(inputFile).toString(); }
        catch(e) { throw "Couldn't read file " + inputFile; }
        assemble();
    }
}
catch(e)
{
    console.error(e);
    process.exit(1);
}

function writeSize(size)
{
    if(sizeOutFD !== null)
    {
        fs.write(sizeOutFD, size + '\n', err => err && console.warn("Failed writing to size-out"));
        fs.close(sizeOutFD, err => err && console.warn("Failed closing size-out"));
    }
}

function assemble()
{
    // Ensure the output path is correct
    if(outputFile[0] != '/' && outputFile[0] != '.')
    {
        outputFile = './' + outputFile;
    }

    let state = new AssemblyState(assemblyConfig);

    try
    {
        state.compile(code, { haltOnError: true });
        writeSize(state.bytes);
    }
    catch(e)
    {
        writeSize(0);
        console.error(e);
        process.exit();
    }
    let outputStream = fs.createWriteStream(outputFile, {mode: 0o0755});

    let baseAddr = state.instructions.address;
    let fileStartAddr = Math.floor((baseAddr - ELF_SIZE) / 0x1000) * 0x1000 + ELF_SIZE;

    ELFHeader.EI_MAG = 0x46_4C_45_7F;
    ELFHeader.EI_CLASS = 2;
    ELFHeader.EI_DATA = 1;
    ELFHeader.EI_VERSION = 1;
    ELFHeader.EI_OSABI = 0;
    ELFHeader.EI_VERSION = 0;

    ELFHeader.e_type = 2;
    ELFHeader.e_machine = 0x3E;
    ELFHeader.e_version = 1;
    ELFHeader.e_entry = baseAddr;
    ELFHeader.e_phoff = ELFHeader.length;
    ELFHeader.e_shoff = 0;
    ELFHeader.e_flags = 0;
    ELFHeader.e_ehsize = ELFHeader.length;
    ELFHeader.e_phentsize = ProgramHeader.length;
    ELFHeader.e_phnum = 1;
    ELFHeader.e_shentsize = SectionHeader.length;
    ELFHeader.e_shnum = 0;
    ELFHeader.e_shstrndx = 0;

    outputStream.write(ELFHeader);


    ProgramHeader.p_type = 1;
    ProgramHeader.p_flags = 0b111;
    ProgramHeader.p_offset = ELFHeader.length + ProgramHeader.length;
    ProgramHeader.p_vaddr = ProgramHeader.p_paddr = fileStartAddr;
    ProgramHeader.p_filesz = ProgramHeader.p_memsz = state.bytes + baseAddr - fileStartAddr;
    ProgramHeader.p_align = 0;

    outputStream.write(ProgramHeader);

    
    // Alignment
    outputStream.write(Buffer.alloc(baseAddr - fileStartAddr));

    // Write the code
    outputStream.write(state.dump());

    outputStream.on('close', () => {
        if(!execute) process.exit();
        let proc = child_process.execFile(outputFile, runtimeArgs);
        process.stdin.pipe(proc.stdin);
        proc.stderr.pipe(process.stderr);
        proc.stdout.pipe(process.stdout);

        proc.on('close', (code, signal) => {
            if(!signal)
                process.exit(code);
            
            let errLine = null;
            let pos = "on";
            let registers = null;

            try
            {
                let coreDumpLocation = fs.readFileSync("/proc/sys/kernel/core_pattern").toString().trim();
                if(coreDumpLocation[0] == '|' || coreDumpLocation.includes('%')) throw "";
                let data = fs.readFileSync(coreDumpLocation);
                let lastIP = null;
                
                let e_phoff = Number(data.readBigInt64LE(0x20));
                let e_phentsize = data.readInt16LE(0x36);

                for(let e_phnum = data.readInt16LE(0x38); e_phnum--; e_phoff += e_phentsize)
                {
                    if(data.readInt32LE(e_phoff) != 4)
                        continue;
                    
                    let p_offset = Number(data.readBigInt64LE(e_phoff + 8));
                    let pt_regs = 124 + p_offset + Math.ceil(data.readInt32LE(p_offset) / 4) * 4;
                    registers = {};

                    // Order taken from https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/ptrace.h#L56
                    for(let regName of "r15 r14 r13 r12 rbp rbx r11 r10 r9 r8 rax rcx rdx rsi rdi orig_rax rip cs rflags rsp ss".split(' '))
                    {
                        registers[regName] = data.readBigUInt64LE(pt_regs);
                        pt_regs += 8;
                    }
                    lastIP = Number(registers['rip']);
                    break;
                }

                if(lastIP !== null)
                {
                    if(lastIP < state.instructions.address)
                        throw "";

                    if(signal == "SIGTRAP" || signal == "SIGSYS")
                        lastIP--; // Weird behavior with breakpoints

                    state.iterate((instr, line) => {
                        if(errLine)
                            return;
                        if(instr.address + instr.length > lastIP)
                            errLine = line;
                    });
                    if(!errLine)
                    {
                        pos = 'after';
                        errLine = (state.source.match(/\n/g) || []).length + 1;
                    }
                }
            }
            catch(e) {}

            let regFormat = reg => registers[reg].toString(16).toUpperCase().padStart(16, '0');

            
            signal = ({
                SIGFPE:  'floating point error',
                SIGILL:  'illegal instruction',
                SIGSEGV: 'segmentation violation',
                SIGBUS:  'bus error',
                SIGABRT: 'abort',
                SIGTRAP: 'breakpoint trap',
                SIGEMT:  'emulator trap',
                SIGSYS:  'bad system call'
            })[signal] || signal;
            console.warn(`Signal: ${signal}${
                errLine !== null ? ` ${pos} line ${errLine}` : ''
            } ${
                registers && registers['rip'] !== undefined ? `(%rip was ${regFormat('rip')})` : ''
            }`);
            
            if(registers !== null)
            {
                console.warn("Registers:");
                let regTab = reg => `%${reg.padEnd(4, ' ')}= ${regFormat(reg)}`;
                for(let regNames of "rax r8|rbx r9|rcx r10|rdx r11|rsi r12|rdi r13|rsp r14|rbp r15".split('|'))
                {
                    let [reg1, reg2] = regNames.split(' ');
                    console.warn('    ' + regTab(reg1) + '        ' + regTab(reg2));
                }
                
                let flag = i => registers['rflags'] & 1n << BigInt(i) ? 1 : 0;
                let tmp;
                let flagTab = (name, id, length, options = []) =>
                    ('    ' + name.padEnd(length, ' ') + ' = ' + (tmp = flag(id)) +
                    ' (' + options[tmp] + ')').padEnd(31, ' ');
                let twoFlagTab = (name1, id1, options1, name2, id2, options2) =>
                    console.warn(flagTab(name1, id1, 9, options1) + (name2 ? flagTab(name2, id2, 6, options2) : ''));

                console.warn(`Flags (${regFormat('rflags')}):`);
                
                twoFlagTab('Carry', 0, ['no carry', 'carry'], 'Zero', 6, ["isn't zero", 'is zero']);
                twoFlagTab('Overflow', 11, ['no overflow', 'overflow'], 'Sign', 7, ['positive', 'negative']);
                twoFlagTab('Direction', 10, ['up', 'down'], 'Parity', 2, ['odd', 'even']);
                twoFlagTab('Adjust', 4, ['no aux carry', 'aux carry']);
            }

            process.exit();
        });
    });

    outputStream.close();
}