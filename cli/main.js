#!/usr/bin/env node

import fs from "fs";

import { AssemblyState } from "@defasm/core";
import { debug } from "./debug.js";
import { createExecutable, createObject } from "./files.js";


let args = process.argv.slice(2);
let code = undefined;
let sizeOutFD = null;
let execute = false;
let outputFile = null, inputFile = null;
let runtimeArgs = [];
let assemblyConfig = {};

if(args[0] === '-h' || args[0] === '--help')
{
    console.log(
`Usage: defasm [options] [file]
Options:
  -i, --intel               Use Intel syntax when assembling (defaults to AT&T)
  -o, --output FILE         Set the path to the output file (defaults to 'a.out' in current directory, or /tmp/asm if --run is provided)
  -r, --run [arguments...]  If given, the program will assemble the code and execute it. All parameters following this flag are sent to the program as runtime arguments
  --size-out=FD             Set the file descriptor to write the number (in ASCII) of bytes generated by the assembler to.`
    );
    process.exit();
}

try
{
    while(args.length > 0)
    {
        let arg = args.shift();
        if(arg[0] !== '-')
        {
            inputFile = arg;
            continue;
        }

        if(arg.startsWith('--size-out='))
        {
            sizeOutFD = parseInt(arg.slice('--size-out='.length));
            if(isNaN(sizeOutFD))
                throw "--size-out expects a file descriptor";
        }
        else switch(arg)
        {
            case '-r':
            case '--run':
                execute = true;
                runtimeArgs = args;
                args = [];
                break;

            case '-o':
            case '--output':
                
                outputFile = args.shift();
                if(outputFile === undefined)
                    throw "No output file given";
                break;

            case '-i':
            case '--intel':
                assemblyConfig.intel = true;
                break;
            
            default:
                throw "Unknown flag " + arg;
        }
    }

    if(outputFile === null)
        outputFile = execute ? '/tmp/asm' : 'a.out';

    if(inputFile === null)
    {
        code = "";
        process.stdin.on("data", x => code += x.toString());
        process.stdin.on("end", assemble);
    }
    else
    {
        try { code = fs.readFileSync(inputFile).toString(); }
        catch(e) { throw "Couldn't read file " + inputFile; }
        assemble();
    }
}
catch(e)
{
    console.error(e);
    process.exit(1);
}

function assemble()
{
    // Ensure the output path is correct
    if(outputFile[0] != '/' && outputFile[0] != '.')
    {
        outputFile = './' + outputFile;
    }

    let state = new AssemblyState(assemblyConfig), size = 0;

    try
    {
        state.compile(code, { haltOnError: true });
    }
    catch(e)
    {
        console.error(e);
        return;
    }
    finally
    {
        size = state.head.length();
        if(sizeOutFD !== null)
        {
            fs.write(sizeOutFD, size + '\n', err => err && console.warn("Failed writing to size-out"));
            fs.close(sizeOutFD, err => err && console.warn("Failed closing size-out"));
        }
    }

    if(execute)
    {
        try
        {
            createExecutable(outputFile, state);
            debug(outputFile, runtimeArgs, state);
        }
        catch(e)
        {
            console.error(e);
            process.exit(-1);
        }
    }
    else
        createObject(outputFile, state);
    process.exit(0);
}