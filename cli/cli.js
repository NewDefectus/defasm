#!/usr/bin/env node

import fs from "fs";
import { arch } from "os";

import { AssemblyState } from "@defasm/core";
import { createExecutable, createObject, debug } from "./main.js";


let args = process.argv.slice(2);
let code = undefined;
let sizeOutFD = null;
let makeExecutable = false, execute = false, writable = false;
let outputFile = null, inputFile = null;
let runtimeArgs = [];
let assemblyConfig = {};

if(args[0] === '-h' || args[0] === '--help')
{
    console.log(
`Usage: defasm [options] [file]
Options:
  -i, --intel               Use Intel syntax when assembling (defaults to AT&T)
  -m32, -m64                Compile for 32- or 64-bit machines, respectively (defaults to whatever the current machine supports, or 64-bit if irrelevant)
  -o, --output FILE         Set the path to the output file (defaults to 'a.out' in current directory, or /tmp/asm if --run is provided)
  -x, --executable          Generate an executable file from the input file (note that it will not be linked against other files)
  -w, --writable            Make the .text section writable
  -r, --run [arguments...]  If given, the assembler will execute the program and print crash information. All parameters following this flag are sent to the program as runtime arguments
  --size-out=FD             Set the file descriptor to write the number (in ASCII) of bytes generated by the assembler to`
    );
    process.exit();
}

if(arch() === 'ia32')
    assemblyConfig.bitness = 32;

try
{
    while(args.length > 0)
    {
        let arg = args.shift();
        if(arg[0] !== '-')
        {
            inputFile = arg;
            continue;
        }

        if(arg.startsWith('--size-out='))
        {
            sizeOutFD = parseInt(arg.slice('--size-out='.length));
            if(isNaN(sizeOutFD))
                throw "--size-out expects a file descriptor";
        }
        else switch(arg)
        {
            case '-r':
            case '--run':
                makeExecutable = execute = true;
                runtimeArgs = args;
                args = [];
                break;

            case '-o':
            case '--output':
                outputFile = args.shift();
                if(outputFile === undefined)
                    throw "No output file given";
                break;

            case '-m32':
                assemblyConfig.bitness = 32;
                break;

            case '-m64':
                assemblyConfig.bitness = 64;
                break;

            case '-i':
            case '--intel':
                assemblyConfig.syntax = { intel: true, prefix: false };
                break;
            
            case '-x':
            case '--executable':
                makeExecutable = true;
                break;

            case '-w':
            case '--writable':
                assemblyConfig.writableText = true;
                break;
            
            default:
                throw "Unknown flag " + arg;
        }
    }

    if(outputFile === null)
        outputFile = execute ? '/tmp/asm' : 'a.out';

    if(inputFile === null)
    {
        code = "";
        process.stdin.on("data", x => code += x.toString());
        process.stdin.on("end", assemble);
    }
    else
    {
        try { code = fs.readFileSync(inputFile).toString(); }
        catch(e) { throw "Couldn't read file " + inputFile; }
        assemble();
    }
}
catch(e)
{
    console.error(e);
    process.exit(1);
}

function assemble()
{
    // Ensure the output path is correct
    if(outputFile[0] != '/' && outputFile[0] != '.')
        outputFile = './' + outputFile;

    let state = new AssemblyState(assemblyConfig), size = 0;

    try
    {
        state.compile(code, { haltOnError: true });
    }
    catch(e)
    {
        console.error(e);
        return;
    }
    finally
    {
        size = state.head.length();
        if(sizeOutFD !== null)
        {
            fs.write(sizeOutFD, size + '\n', err => err && console.warn("Failed writing to size-out"));
            fs.close(sizeOutFD, err => err && console.warn("Failed closing size-out"));
        }
    }

    if(makeExecutable)
    {
        createExecutable(outputFile, state);
        if(execute)
            process.exit(debug(outputFile, runtimeArgs, state));
    }
    else
        createObject(outputFile, state);
    
    process.exit(0);
}